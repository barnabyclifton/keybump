#!/usr/bin/env python
"""
  keybump
  ~~~~~~~

  helper script to perform a project release, and follow the semantic
  versioning specification.

  :copyright: (c) 2013 by gregorynicholas.
  :license: BSD, see LICENSE for more details.
"""
import re
import sys
import subprocess
from sys import exit
from optparse import OptionParser
from datetime import datetime
from subprocess import PIPE, STDOUT


SEP = '-'
DEFAULT_CHANGELOG_FILE = 'CHANGES.md'
DEFAULT_TAG_MSG_FMT = "Version bumped to {}"
DEFAULT_COMMIT_MSG_FMT = "Version bumped to {}"
DEFAULT_CHANGELOG_FMT = """
Version {{version}}
----------------------

Released on {{date}}

{{summaries}}

"""
MAJOR_BUMP = "major"
MINOR_BUMP = "minor"
PATCH_BUMP = "patch"
BUMP_TYPES = [MAJOR_BUMP, MINOR_BUMP, PATCH_BUMP]
BANNER = """
edit the changelog summaries. press <enter> to complete:
========================================================
"""
INFO_FMT = """project version information:

  latest tag:   {}
  current tag:  {}
  version id:   {}"""

version_reg = re.compile('^Version\s+(.*)')
release_reg = re.compile('Released on (\d+-\d+-\d+)(?:, codename (.*))?(?i)')


class Release(object):
  """
  object representing a version release.
  """

  def __init__(self, version=None, date=None, codename=None, summaries=None,
               changelog_fmt=None, tag_msg_fmt=None):
    """
      :param version: string version in the format: [x].[x].[x]
    """
    self.version = version or "0.0.0"
    self.date = self.parse_datestr(date or today_str())
    self.codename = codename
    self.set_summaries(summaries or [])
    self.changelog_fmt = changelog_fmt or DEFAULT_CHANGELOG_FMT
    self.tag_msg_fmt = tag_msg_fmt or DEFAULT_TAG_MSG_FMT
    self.summaryitem_fmt = "\n    * "

  @property
  def tag_msg(self):
    return self.tag_msg_fmt.format(self.version)

  @property
  def commit_msg(self):
    return self.changelog_fmt.format(self.version)

  @property
  def date_msg(self):
    return self.date.strftime('%Y-%m-%d')

  def parse_datestr(self, datestr):
    """
      :param datestr: string date in the format: %Y-%m-%d
      :returns: `datetime.date` object parsed from the datestr param.
    """
    datestr = _date_clean_re.sub(r'\1', datestr)
    # return datetime.strptime(datestr, '%B %d %Y')
    return datetime.strptime(datestr, '%Y-%m-%d')

  def set_summaries(self, summaries):
    self.summaries = self.clean_commit_summaries(summaries)

  def clean_commit_summaries(self, summaries):
    """
    cleans up summaries. removes merge commit messages.
    """
    MIN_SUMMARY_LENGTH = 10
    for line in summaries:
      # merge commits..
      if line.startswith('Merge branch'):
        summaries.remove(line)
      elif line.startswith('Merge pull request'):
        summaries.remove(line)
      elif line == 'whitespace.':
        summaries.remove(line)
      elif len(line) < MIN_SUMMARY_LENGTH:
        summaries.remove(line)
    return summaries

  def bump_num(self, version, bump_type=PATCH_BUMP):
    """
      :param bump_type:
        version bump type. one of:
          major  [x].0.0    minor  x.[x].0    patch  x.x.[x]
      :returns:
    """
    try:
      switch = {
        'major': lambda: [version[0] + 1, 0, 0],
        'minor': lambda: [version[0], version[1] + 1, 0],
        'patch': lambda: [version[0], version[1], version[2] + 1]}
      return '.'.join(map(str, switch.get(bump_type)()))
    except ValueError:
      fail("version string is not numeric..")

  def bump(self, bump_type=PATCH_BUMP):
    self.version = self.bump_num(
      [int(v) for v in self.version.split('.')], bump_type)

  def bump_changelog(self):
    """
      :param version: string name of the new version to bump to.
    """
    rv = self.changelog_fmt.replace("{{version}}", self.version)
    rv = rv.replace("{{date}}", self.date_msg)
    rv = rv.replace(
      "{{summaries}}",
      "    * " + self.summaryitem_fmt.join(self.summaries))
    return rv


_date_clean_re = re.compile(r'(\d+)(st|nd|rd|th)')


def today_str():
  return datetime.now().strftime('%Y-%m-%d')


def get_changelog_summaries_since(last_tag):
  """
    :param last_tag:
    :returns:
  """
  sep = "__||__"
  rv = sh("git log --no-merges --pretty=%B{} {}..".format(sep, last_tag))
  return [x.strip() for x in rv.split(sep)]


def prepend_changelog(path, data):
  contents = ""
  with open(path, 'r') as f:
    if isinstance(data, basestring):
      contents = data + "\n" + f.read()
    else:
      contents = f.readlines()
  write_changelog(path, contents)


def write_changelog(path, data):
  with open(path, 'w') as f:
    if isinstance(data, basestring):
      f.write(data)
    else:
      f.writelines(data)


def parse_changelog(changelog_file, last_tag, last_version):
  """
  parses the contents of the changelog file.

    :param last_tag:
    :param last_version:
    :returns: instance of a `Release` object.
  """
  with open(changelog_file) as f:
    lineiter = iter(f)
    for line in lineiter:

      # parse the last version..
      ver_match = version_reg.search(line.strip())
      if ver_match is None:
        continue
      version = ver_match.group(1).strip()
      value = lineiter.next()
      if not value.count(SEP):
        continue

      # parse the release data and codename..
      while 1:
        changelog_summary = lineiter.next().strip()
        if changelog_summary:
          break
      rel_match = release_reg.search(changelog_summary)
      if rel_match is None:
        continue
      datestr, codename = rel_match.groups()

      # parse the change summary messages..
      summaries = []
      while 1:
        summary = lineiter.next().strip()
        if summary:
          summaries.append(summary)
        else:
          break

      return Release(
        version, datestr, codename, summaries)
    # no result was returned.. see if it's because the file was empty..
    if (len(f.read().strip()) > 1):
      fail("unable to parse the change log contents.. verify it's in the "
           "correct format.")


def set_default_changelog(changelog_fmt, version):
  dt = today_str()
  contents = changelog_fmt.replace('{{date}}', dt)
  contents = contents.replace('{{version}}', version)
  contents = contents.replace('{{summaries}}', "  * initial version")
  write_changelog(contents)
  return Release(
    version, dt, None, [])


# git helpers..


def get_current_git_tag():
  tag = sh("git describe")
  return tag.strip()


def get_current_or_last_git_tag(tags):
  """
    :param tags:
      list of git tags, sorted by the date of the commit it points to.
  """
  tag = get_current_git_tag()
  if tag not in tags:
    # describe makes up it's own tag names, so make sure we have a real tag
    # to build from, else we're fucked.
    tag = tags[-1]
  return tag


def get_git_tags():
  """
    :returns:
      list of git tags, sorted by the date of the commit it points to.
  """
  tags = sh("git for-each-ref --format='%(tag)' refs/tags")
  # strips single quotes that for some reason are carrying over..
  return [x for x in tags.splitlines()]


def git_is_clean():
  """
    :returns: boolean if there is a dirty index.
  """
  return str(sh('git diff --quiet')) == "0"


def git_diff_files():
  """
    :returns: list of string names of the files that are dirty.
  """
  files = sh("git diff --minimal --numstat")
  return [x.split('\t')[-1] for x in files.splitlines()]


def git_checkout(id):
  """
    :param id: string identifier of the commit'ish to checkout.
  """
  info('checking out: "{}"', id)
  sh("git checkout {}".format(id))


def git_stash():
  """
  stashes current changes.
  """
  sh("git stash", capture=False)


def make_git_commit(changelog_file, message):
  """
    :param message: string message for the commit.
  """
  info('making git commit: "{}"', message)
  sh("git add {} && git commit -am {}".format(
    changelog_file, message), capture=False)


def make_git_tag(msg, tag_name):
  """
    :param tag_name: string name for the tag.
  """
  info('making git tag: "{}"', tag_name)
  sh("git tag {} -m {}".format(tag_name, msg))


def push_to_remote():
  """
  pushes current branch and tags to remote.
  """
  # don't call --all here on purpose..
  sh("git push && git push --tags", capture=False)


def ensure_clean_index(options):
  if git_is_clean():
    return
  files = git_diff_files()
  msg = """cannot bump the version with a dirty git index.
you have uncommitted changes. stash your changes, or
do something to the following files:

  {}\n""".format('\n  '.join(files))
  if options.skip_interactive:
    fail(msg)
  # clean the index..
  info(msg)
  do_stash = raw_input(
    "want keybump to snort ..achem stash.. your changes? "
    "[Y / n]: ").upper()
  if do_stash != "Y":
    pass  # fail("cannot continue with dirty index..")
  info("\nok, you asked for it..\n")
  git_stash()
  ensure_clean_index(options)


# python package..

def set_version_in_file(filename, version_number, pattern):
  """
    :param filename:
    :param version_number:
    :param pattern:
  """
  changed = []

  def inject_version(match):
    before, old, after = match.groups()
    changed.append(True)
    return before + version_number + after

  with open(filename, 'r') as f:
    contents = re.sub(
      r"^(\s*%s\s*=\s*')(.+?)(')(?sm)" % pattern, inject_version, f.read())
  if len(changed) < 1:
    fail(
      "could not set init file version. pattern {} not found in {}",
      pattern, filename)
  with open(filename, 'w') as f:
    f.write(contents)


def set_init_py_version(version):
  """
    :param version:
  """
  info('setting __init__.py version to: {}', version)
  set_version_in_file('__init__.py', version, '__version__')


def set_setup_py_version(version):
  """
    :param version:
  """
  info('Setting setup.py version to {}', version)
  set_version_in_file('setup.py', version, 'version')


def setup_py_distribute():
  sh("setup.py clean sdist upload".format(sys.executable), capture=False)


# cli interface..

def sh(command, capture=True, ignore_error=None, cwd=None):
  """
  runs an external command. if `capture=True`, the output of the command will
  be captured and returned as a string.

  if the command has a non-zero return code raise a buildfailure. you can pass
  `ignore_error=True` to allow non-zero return codes to be allowed to pass
  silently, silently into the night. passing `cwd='some/path'` will chdir to
  'some/path' before exectuting the command.
  """
  # if capture is true, then set ignore_error to true by default.
  # otherwise, ignore_error defaults to false.
  if capture and ignore_error is None:
    ignore_error = True

  def runpipe():
    kwargs = {"shell": True, "cwd": cwd}
    if capture:
      kwargs["stderr"] = STDOUT
      kwargs["stdout"] = PIPE
    else:
      subprocess.Popen(command, **kwargs).wait()
      return
    p = subprocess.Popen(command, **kwargs)
    p_stdout = p.communicate()[0]
    if p_stdout is not None:
      p_stdout = p_stdout.decode(sys.getdefaultencoding())
    if p.returncode and not ignore_error:
      if capture and p_stdout is not None:
        fail(p_stdout)
      fail("command error: {}. return code: {}", command, p.returncode)
    if capture:
      return p_stdout
  return runpipe()


def fail(message, *args):
  print >> sys.stderr, 'error:', message.format(*args)
  exit(1)


def info(message, *args):
  print >> sys.stdout, message.format(*args)
  # print >> sys.stderr, message % args


def show_project_version_info(current_tag, last_tag, last_version):
  """
  prints project version information and exits without error.
  """
  info(INFO_FMT, last_tag, current_tag, last_version)
  exit(0)

parser = OptionParser(
  description="description: keybump makes following the semantic versioning "
 "specification a breeze. \n"
 "if called with no options, keybump will print the current git repository's "
 "tag + version name",
  prog="keybump",
  usage="%progs [options]")

parser.add_option(
  '--skip-interactive', dest='skip_interactive', action='store_true',
  default=False, help="skips interactive command line interface.")

parser.add_option(
  "--bump", dest="bump_type", choices=BUMP_TYPES,
  help="""version bump type to increment. must be
  one of:
    major [x].x.x
    minor x.[x].x
    patch x.x.[x]""")

parser.add_option(
  '--skip-commit', dest='skip_commit', action='store_true',
  default=False, help="skips creating a git tag at the current HEAD")

parser.add_option(
  '--skip-tag', dest='skip_tag', action='store_true',
  default=False, help="skips creating a git tag at the current HEAD")

parser.add_option(
  '--skip-push', dest='skip_push', action='store_true',
  default=False, help="skips pushing to the remote origin")

parser.add_option(
  '--pypi_distribute', dest='pypi_distribute', action='store_true',
  help="build the release and upload to the python package index")

# todo: implement message formats as cli options..
# https://github.com/gregorynicholas/keybump/issues/5

parser.add_option(
  '--changelog-file', dest='changelog_file', default=DEFAULT_CHANGELOG_FILE,
  help="path to the changelog history file.")

parser.add_option(
  '--changelog-fmt', dest='changelog_fmt', default=DEFAULT_CHANGELOG_FMT,
  help="string format of the changelog version summary")

parser.add_option(
  '--git-commit-fmt', dest='git_commit_fmt', default=DEFAULT_COMMIT_MSG_FMT,
  help="string format of the git commit message")

parser.add_option(
  '--git-tag-fmt', dest='git_tag_fmt', default=DEFAULT_TAG_MSG_FMT,
  help="string format of the git tag")


def main():
  (options, args) = parser.parse_args()

  tags = get_git_tags()
  # what ro do on first time run? no tags yet..
  if len(tags) < 1:
    fail("""create a tag for version: 0.0.0 and try again.. sorry, we're
still ghetto riggin this script along..""")
    # todo: implement condition for new project without tags / version.
    # https://github.com/gregorynicholas/keybump/issues/2

  current_tag = get_current_or_last_git_tag(tags)
  last_tag = tags[-1]
  last_version = "0.0.0"
  if len(current_tag) > 0:
    non_decimal = re.compile(r'[^\d.]+')
    last_version = non_decimal.sub('', current_tag)

  if not options.bump_type:
    show_project_version_info(
      current_tag, last_tag, last_version)

  ensure_clean_index(options)
  last_release = parse_changelog(
    options.changelog_file, current_tag, last_version)
  if last_release is None:
    msg = "could not parse release from changelog history in {}.".format(
      options.changelog_file)
    if not options.skip_interactive:
      # set to initial version..
      info(msg)
      set_initial = raw_input("""
that's beacuse the file is empty. want keybump to
"setup the initial file?  [Y / n]: """).upper()
      if set_initial != "Y":
        fail(msg)
      info("\nok, you asked for it..\n")
      last_release = set_default_changelog(
        options.changelog_fmt, last_version)
    else:
      fail(msg)

  # increment the version..
  new_release = Release(
    last_release.version, today_str(), last_release.codename)
  new_release.bump()
  if new_release.version in tags:
    fail("version `{}` is already tagged", new_release.version)

  info(""""previous release: {} (codename: {}, date: {})
creating release: {} (codename: {}, date: {})\n""",
       last_release.version, last_release.codename, last_release.date,
       new_release.version, new_release.codename, new_release.date)

  # todo: add optional step to add a separate [version]-dev..
  # https://github.com/gregorynicholas/keybump/issues/3
  # setup the dev new version..
  # dev_version = new_version + '-dev'

  summaries = get_changelog_summaries_since(current_tag)
  new_release.set_summaries(summaries)
  changelog_summary = new_release.bump_changelog()

  # todo: add inline changelog summary editing..
  # https://github.com/gregorynicholas/keybump/issues/4
  # present string to user to customize before continuing..
  # if not options.skip_interactive:
  #   readline.set_startup_hook(
  #     lambda: readline.insert_text(changelog_summary))
  #   changelog_summary = raw_input(BANNER)

  if not options.skip_interactive:
    raw_input("""========================================================
review + edit your CHANGES.md changelog summary. when you
are finished, press any key here to continue..
""")
  prepend_changelog(options.changelog_file, changelog_summary)

  # todo: add as optional step to set python __init__.py version..
  # set_init_version(new_version)

  # todo: add as optional step to set python setup.py version..
  # set_setup_version(new_version)

  if not options.skip_commit:
    make_git_commit(options.changelog_file, new_release.tag_msg)

  if not options.skip_tag:
    make_git_tag(new_release.tag_msg, new_release.version)

  if not options.skip_push:
    push_to_remote()

  info("""
========================================================
release complete: {}.
""".format(new_release.tag_msg))

  # optional pypi releases..

  if options.pypi_distribute:
    setup_py_distribute()
    info("version built + released and uploaded to python package index..")

  exit(0)


if __name__ == '__main__':
  main()
