#!/usr/bin/env python
"""
  keybump
  ~~~~~~~

  helper script to perform a project release, and follow the semantic
  versioning specification.

  :copyright: (c) 2013 by gregorynicholas.
  :license: BSD, see LICENSE for more details.
"""
import re
import sys
from sys import exit
from optparse import OptionParser
from datetime import datetime
from subprocess import Popen
from subprocess import PIPE, STDOUT


SUMMARY_SEPARATOR = "-"
DEFAULT_CHANGELOG_FILE = "CHANGES.md"
DEFAULT_TAG_MSG_FMT = "Version bumped to {}"
DEFAULT_COMMIT_MSG_FMT = "Version bumped to {}"
DEFAULT_CHANGELOG_FMT = """
Version {{version}}
----------------------

Released on {{date}}

{{summaries}}

"""
MAJOR_BUMP = "major"
MINOR_BUMP = "minor"
PATCH_BUMP = "patch"
BUMP_TYPES = [MAJOR_BUMP, MINOR_BUMP, PATCH_BUMP]
BANNER = """
edit the changelog summaries. press <enter> to complete:
========================================================
"""
INFO_FMT = """project version information:

  latest tag:   {}
  current tag:  {}
  version id:   {}"""

version_reg = re.compile('^Version\s+(.*)')
release_header_reg = re.compile(
  'Released on (\d+-\d+-\d+)(?:, codename (.*))?(?i)')


class BaseSummaryFormatter(object):
  """
  base class for a commit summary formatter.
  """


class SummaryFormatter(BaseSummaryFormatter):
  """
  commit summary formatter.
  """


class Project(object):
  """
  """

  def __init__(self, changelog_file, skip_interactive):
    """
      :param changelog_file:
      :param skip_interactive:
    """
    self.changelog_file = changelog_file
    self.skip_interactive = skip_interactive
    self.releases = []
    self.tags = []
    self.current_tag = None
    self.last_version_num = "0.0.0"

  @property
  def last_release(self):
    return self.releases[-1]

  @property
  def last_tag(self):
    return self.tags[-1]

  def parse_git_tags(self):
    """
    sets the git tags and current repo index git tag.
    """
    self.tags = get_git_tags()
    # what to do on first time run? no tags yet..
    if len(self.tags) < 1:
      fail("""create a tag for version: 0.0.0 and try again.. sorry, we're
  still ghetto-riggin this script along.. workin on it..""")
      # todo: implement condition for new project without tags / version.
      # https://github.com/gregorynicholas/keybump/issues/2
    self.current_tag = self._current_or_last_git_tag()

  def _current_or_last_git_tag(self):
    """
      :returns: string name of the current or last git tag.
    """
    current_tag = get_current_git_tag()
    if current_tag not in self.tags:
      # describe makes up it's own tag names, so make sure we have a real tag
      # to build from, else we're fucked.
      current_tag = self.last_tag
    return current_tag

  def parse_versions(self):
    if not self.current_tag or len(self.current_tag) < 1:
      return
    non_decimal = re.compile(r'[^\d.]+')
    self.last_version_num = non_decimal.sub('', self.current_tag)

  def parse_releases(self):
    """
    sets the releases.
    """
    releases = self.parse_changelog_releases()
    if len(releases) < 1:
      self.setup_initial_release()

  def parse_changelog_releases(self):
    """
    parses the contents of the changelog file, and returns a `Release` object
    from the latest changelog summary.

      :returns: list of instance of a `Release` objects.
    """
    result = []
    with open(self.changelog_file) as f:
      lineiter = iter(f)
      for line in lineiter:

        # parse the last version..
        ver_match = version_reg.search(line.strip())
        if ver_match is None:
          continue
        version_num = ver_match.group(1).strip()
        value = lineiter.next()
        if not value.count(SUMMARY_SEPARATOR):
          continue

        # parse the release data and codename..
        while 1:
          release_header = lineiter.next().strip()
          if release_header:
            break
        rel_match = release_header_reg.search(release_header)
        if rel_match is None:
          continue
        datestr, codename = rel_match.groups()

        # parse the change summary messages..
        summaries = []
        while 1:
          summary = lineiter.next().strip()
          if summary:
            summaries.append(summary)
          else:
            break

        result.append(Release(
          version_num, datestr, codename, summaries))

      # no result was returned.. see if it's because the file was empty..
      if (len(f.read().strip()) > 1):
        fail("unable to parse the change log contents.. "
             "verify it's in the correct format.")

      return result

  def setup_initial_release(self):
    """
    """
    msg = "could not parse release from changelog history in {}.".format(
      self.changelog_file)
    # fail and exit..
    if self.skip_interactive:
      fail(msg)
    # don't fail, set to initial version..
    info(msg)
    set_initial = raw_input("""
  that's beacuse the file is empty. want keybump to
  setup the initial file?  [Y / n]: """).upper()
    if set_initial != "Y":
      fail(msg)
    info("""
  ok, you asked for it..
    """)
    rel = self.create_initial_release(self.last_version_num)
    self.releases.append(rel)

  def create_initial_release(self, version_num):
    dt = today_str()
    contents = self.changelog_fmt.replace('{{date}}', dt)
    contents = contents.replace('{{version}}', version_num)
    contents = contents.replace('{{summaries}}', "  * initial version")
    write(self.changelog_file, contents)
    return Release(version_num, dt, None, [])

  def prepend_changelog(self, data):
    contents = ""
    with open(self.changelog_file, 'r') as f:
      if isinstance(data, basestring):
        contents = data + "\n" + f.read()
      else:
        contents = f.readlines()
    write(self.changelog_file, contents)

  def new_release(self):
    """
      :returns: instance of a `Release` object.
    """
    release = Release(
      self.last_release.version_num, today_str(), self.last_release.codename)
    release.bump()
    if release.version_num in self.tags:
      fail("version `{}` is already tagged", release.version_num)
    summaries = self.get_changelog_summaries_since(self.current_tag)
    release.set_summaries(summaries)
    return release

  def get_changelog_summaries_since(self, last_tag):
    """
      :param last_tag:
      :returns:
    """
    sep = "__||__"
    rv = sh("git log --no-merges --pretty=%B{} {}..".format(sep, last_tag))
    return [x.strip() for x in rv.split(sep)]


class Release(object):
  """
  object representing a version release.
  """

  def __init__(self, version_num=None, datestr=None, codename=None,
               summaries=None, changelog_fmt=None, tag_msg_fmt=None):
    """
      :param version_num: string version in the format: [x].[x].[x]
    """
    self.version_num = version_num or "0.0.0"
    self.set_date(datestr)
    self.codename = codename
    self.set_summaries(summaries or [])
    self.changelog_fmt = changelog_fmt or DEFAULT_CHANGELOG_FMT
    self.tag_msg_fmt = tag_msg_fmt or DEFAULT_TAG_MSG_FMT
    self.summaryitem_fmt = "\n    * "

  @property
  def tag_msg(self):
    return self.tag_msg_fmt.format(self.version_num)

  @property
  def commit_msg(self):
    return self.changelog_fmt.format(self.version_num)

  @property
  def datestr(self):
    return self.date.strftime('%Y-%m-%d')

  def set_date(self, datestr=None):
    """
      :param datestr: string date in the format: %Y-%m-%d. defaults to today.
    """
    self.date = self._parse_datestr(datestr or today_str())

  def _parse_datestr(self, datestr):
    """
      :param datestr: string date in the format: %Y-%m-%d
      :returns: `datetime.date` object parsed from the datestr param.
    """
    date_clean_re = re.compile(r'(\d+)(st|nd|rd|th)')
    datestr = date_clean_re.sub(r'\1', datestr)
    return datetime.strptime(datestr, '%Y-%m-%d')

  def set_summaries(self, summaries):
    self.summaries = self.format_summary_items(summaries)

  def format_summary_items(self, summaries):
    """
    cleans summary lines of text. removes merge commit messages.

      :returns:
    """
    MIN_SUMMARY_LENGTH = 10
    SKIP_PREFIXES = ['MERGE BRANCH', 'MERGE PULL REQUEST']
    SKIP_EQUALITY = ['WHITESPACE']
    for line in summaries:
      # merge commits..
      lu = line.upper()
      for skip in SKIP_PREFIXES:
        if lu.startswith(skip):
          summaries.remove(line)
      for skip in SKIP_EQUALITY:
        if lu == skip:
          summaries.remove(line)
      if len(line) < MIN_SUMMARY_LENGTH:
        summaries.remove(line)
    return summaries

  def _bump_num(self, version_num, bump_type=PATCH_BUMP):
    """
      :param version_num: string version name.
      :param bump_type: version bump type. one of:
          major  [x].0.0    minor  x.[x].0    patch  x.x.[x]
      :returns: concatenated string of the incremented version name.
    """
    # split the version number into a list of ints..
    try:
      version = [int(v) for v in version_num.split('.')]
      switch = {
        'major': lambda: [version[0] + 1, 0, 0],
        'minor': lambda: [version[0], version[1] + 1, 0],
        'patch': lambda: [version[0], version[1], version[2] + 1]}
      return '.'.join(map(str, switch.get(bump_type)()))
    except ValueError:
      fail("version string: {} is an invalid format..", version_num)

  def bump(self, bump_type=PATCH_BUMP):
    self.version_num = self._bump_num(self.version_num, bump_type)

  def get_changelog_summary(self):
    """
      :returns: formatted string of the release changelog summary.
    """
    rv = self.changelog_fmt.replace("{{version}}", self.version_num)
    rv = rv.replace("{{date}}", self.datestr)
    rv = rv.replace(
      "{{summaries}}",
      "    * " + self.summaryitem_fmt.join(self.summaries))
    return rv


# util helpers..


def write(path, data):
  with open(path, 'w') as f:
    if isinstance(data, basestring):
      f.write(data)
    else:
      f.writelines(data)


def today_str():
  return datetime.now().strftime('%Y-%m-%d')


# git helpers..


def get_current_git_tag():
  """
    :returns: string of the current git tag on the git index, not the latest
              tag version created.
  """
  return sh("git describe").strip()


def get_git_tags():
  """
    :returns:
      list of git tags, sorted by the date of the commit it points to.
  """
  tags = sh("git for-each-ref --format='%(tag)' refs/tags")
  return tags.splitlines()


def git_is_clean():
  """
    :returns: boolean if there is a dirty index.
  """
  return str(sh('git diff --quiet')) == "0"


def git_diff_files():
  """
    :returns: list of string names of the files that are dirty.
  """
  files = sh("git diff --minimal --numstat")
  return [x.split('\t')[-1] for x in files.splitlines()]


def git_checkout(id):
  """
    :param id: string identifier of the commit'ish to checkout.
  """
  info('checking out: "{}"', id)
  sh("git checkout {}".format(id))


def git_stash():
  """
  stashes current changes.
  """
  sh("git stash", capture=False)


def make_git_commit(changelog_file, message):
  """
    :param message: string message for the commit.
  """
  info('making git commit: "{}"', message)
  sh("git add {} && git commit -am {}".format(
    changelog_file, message), capture=False)


def make_git_tag(msg, tag_name):
  """
    :param tag_name: string name for the tag.
  """
  info('making git tag: "{}"', tag_name)
  sh("git tag {} -m {}".format(tag_name, msg), capture=False)


def push_to_remote():
  """
  pushes current branch and tags to remote.
  """
  # don't call --all here on purpose..
  sh("git push && git push --tags", capture=False)


def ensure_clean_index(skip_interactive=False):
  """
    :param skip_interactive:
  """
  if git_is_clean():
    return
  files = git_diff_files()
  msg = """
  cannot bump the version with a dirty git index.
  you have uncommitted changes. stash your changes, or
  do something to the following files:

  {}\n""".format('\n  '.join(files))
  if skip_interactive:
    fail(msg)
  # clean the index..
  info(msg)
  do_stash = raw_input(
    "want keybump to snort ..achem stash.. your changes? "
    "[Y / n]: ").upper()
  if do_stash != "Y":
    pass  # fail("cannot continue with dirty index..")
  info("""
  ok, you asked for it..
  """)
  git_stash()
  ensure_clean_index(skip_interactive)


# python package..

def set_version_in_file(filename, version_number, pattern):
  """
    :param filename:
    :param version_number:
    :param pattern:
  """
  changed = []

  def inject_version(match):
    before, old, after = match.groups()
    changed.append(True)
    return before + version_number + after

  with open(filename, 'r') as f:
    data_str = re.sub(
      r"^(\s*%s\s*=\s*')(.+?)(')(?sm)" % pattern, inject_version, f.read())
  if len(changed) < 1:
    fail(
      "could not set init file version. pattern {} not found in {}",
      pattern, filename)
  write(filename, data_str)


def set_init_py_version(version):
  """
    :param version:
  """
  info("setting __init__.py version to: {}", version)
  set_version_in_file("__init__.py", version, "__version__")


def set_setup_py_version(version):
  """
    :param version:
  """
  info("setting setup.py version to {}", version)
  set_version_in_file("setup.py", version, "version")


def setup_py_distribute():
  sh("setup.py clean sdist upload".format(sys.executable), capture=False)


# cli interface..

def sh(command, capture=True, ignore_error=None, cwd=None):
  """
  runs an external command. if `capture=True`, the output of the command will
  be captured and returned as a string.

  if the command has a non-zero return code raise a buildfailure. you can pass
  `ignore_error=True` to allow non-zero return codes to be allowed to pass
  silently, silently into the night. passing `cwd='some/path'` will chdir to
  'some/path' before exectuting the command.
  """
  # if capture is true, then set ignore_error to true by default.
  # otherwise, ignore_error defaults to false.
  if capture and ignore_error is None:
    ignore_error = True

  def runpipe():
    kwargs = {"shell": True, "cwd": cwd}
    if capture:
      kwargs["stderr"] = STDOUT
      kwargs["stdout"] = PIPE
    else:
      Popen(command, **kwargs).wait()
      return
    p = Popen(command, **kwargs)
    p_stdout = p.communicate()[0]
    if p_stdout is not None:
      p_stdout = p_stdout.decode(sys.getdefaultencoding())
    if p.returncode and not ignore_error:
      if capture and p_stdout is not None:
        fail(p_stdout)
      fail("command error: {}. return code: {}", command, p.returncode)
    if capture:
      return p_stdout
  return runpipe()


def fail(message, *args):
  print >> sys.stderr, 'error:', message.format(*args)
  exit(1)


def info(message, *args):
  print >> sys.stdout, message.format(*args)


def print_project_info(current_tag, last_tag, version_num):
  """
  prints project version information and exits without error.
  """
  info(INFO_FMT, last_tag, current_tag, version_num)
  exit(0)

parser = OptionParser(
  description="description: keybump makes following the semantic versioning "
 "specification a breeze. \n"
 "if called with no options, keybump will print the current git repository's "
 "tag + version name",
  prog="keybump",
  usage="%progs [options]")

parser.add_option(
  '--skip-interactive', dest='skip_interactive', action='store_true',
  default=False, help="skips interactive command line interface.")

parser.add_option(
  "--bump", dest="bump_type", choices=BUMP_TYPES,
  help="""version bump type to increment. must be
  one of:
    major [x].x.x
    minor x.[x].x
    patch x.x.[x]""")

parser.add_option(
  '--skip-commit', dest='skip_commit', action='store_true',
  default=False, help="skips creating a git tag at the current HEAD")

parser.add_option(
  '--skip-tag', dest='skip_tag', action='store_true',
  default=False, help="skips creating a git tag at the current HEAD")

parser.add_option(
  '--skip-push', dest='skip_push', action='store_true',
  default=False, help="skips pushing to the remote origin")

parser.add_option(
  '--pypi_distribute', dest='pypi_distribute', action='store_true',
  help="build the release and upload to the python package index")

# todo: implement message formats as cli options..
# https://github.com/gregorynicholas/keybump/issues/5

parser.add_option(
  '--changelog-file', dest='changelog_file', default=DEFAULT_CHANGELOG_FILE,
  help="path to the changelog history file.")

parser.add_option(
  '--changelog-fmt', dest='changelog_fmt', default=DEFAULT_CHANGELOG_FMT,
  help="string format of the changelog version summary")

parser.add_option(
  '--git-commit-fmt', dest='git_commit_fmt', default=DEFAULT_COMMIT_MSG_FMT,
  help="string format of the git commit message")

parser.add_option(
  '--git-tag-fmt', dest='git_tag_fmt', default=DEFAULT_TAG_MSG_FMT,
  help="string format of the git tag")


def main():
  (options, args) = parser.parse_args()
  project = Project(options.changelog_file, options.skip_interactive)
  project.parse_git_tags()
  project.parse_versions()
  project.parse_releases()

  if not options.bump_type:
    print_project_info(
      project.current_tag,
      project.last_tag,
      project.last_version_num)

  ensure_clean_index(options.skip_interactive)
  # increment the version..
  new_release = project.new_release()
  info(""""
  previous release: {} (codename: {}, date: {})
  creating release: {} (codename: {}, date: {})
  """,
       project.last_release.version_num, project.last_release.codename,
       project.last_release.date,
       new_release.version_num, new_release.codename, new_release.date)

  # todo: add optional step to add a separate [version]-dev..
  # https://github.com/gregorynicholas/keybump/issues/3
  # setup the dev new version..
  # dev_version = new_version + '-dev'

  changelog_summary = new_release.get_changelog_summary()

  # todo: add inline changelog summary editing..
  # https://github.com/gregorynicholas/keybump/issues/4
  # present string to user to customize before continuing..
  # if not options.skip_interactive:
  #   readline.set_startup_hook(
  #     lambda: readline.insert_text(changelog_summary))
  #   changelog_summary = raw_input(BANNER)

  if not options.skip_interactive:
    all_good = raw_input("""
  ========================================================
  review + edit your CHANGES.md changelog summary.
  continue with the release bump?  [Y / n]: """).upper()
    if all_good != "Y":
      fail("continuation of the release halted..")
      # todo: create rollback flow?

  # add the release changelog summary to the changelog file..
  project.prepend_changelog(changelog_summary)

  # todo: add as optional step to set python __init__.py version..
  # set_init_version(new_version)

  # todo: add as optional step to set python setup.py version..
  # set_setup_version(new_version)

  if not options.skip_commit:
    make_git_commit(options.changelog_file, new_release.tag_msg)

  if not options.skip_tag:
    make_git_tag(new_release.tag_msg, new_release.version_num)

  if not options.skip_push:
    push_to_remote()

  info("""
  ========================================================
  release complete: {}.
  """.format(new_release.tag_msg))

  # optional pypi releases..

  if options.pypi_distribute:
    setup_py_distribute()
    info("version built + released and uploaded to python package index..")

  project.releases.append(new_release)
  exit(0)


if __name__ == '__main__':
  main()
